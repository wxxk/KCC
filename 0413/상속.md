# 상속



### 7.1 상속 개념

> 상속은 부모가 자식에게 물려주는 행위
>
> 객체 지향 프로그램에서도 부모 클래스의 필드와 메소드를 자식클래스에게 물려줄 수 있다.

- 이미 잘 개발된 클래스를 재사용해서 새로운 클래스를 만든다.
- 때문에 중복되는 코드를 줄여 개발 시간을 단축한다.
- 클래스 수정을 최소화 할 수 있다.
  - 부모 클래스를 수정하면 모든 자식 클래스에게 수정 효과



### 7.2 클래스 상속

> 프로그램에서는 자식이 부모를 선택
>
> 자식 클래스를 선언할 때 어떤 부모로부터 상속 받을 것인지 결정

```java
// 부모클래스를 extends 뒤에 기술
public class 자식클래스 extends 부모클래스{
}

// 다중 상속을 허용하지 않는다.(여러 개의 부모 클래스를 상속할 수 없다.)
public class 자식클래스 extends 부모클래스1, 부모클래스2 {		// 에러
}
```

 

### 7.3 부모 생성자 호출

> 자식 객체를 생성하면 부모 객체가 먼저 생성 된 다음에 자식 객체가 생성된다.

```java
/*
 * 모든 객체는 생성자를 호출해야만 한다.
 * 부모 객체도 자식 생성자 맨 첫줄에 숨겨져 있는 super()에 의해 호출된다.
 */

// 자식생성자 선언
public 자식클래스( ... ) {
    super();
    ...
}


/*
 * 컴파일 과정에서 자동으로 추가, 이것은 부모의 기본 생성자를 호출한다.
 * 부모 클래스에 생성자가 없다면 자식 생성자 선언에서 컴파일 에러가 발생한다.
 * 부모 클래스에 기본 생성자가 없고 매개변수를 갖는 생성자만 있다면 super(매개값, ...) 직접 사용
 * 위 코드는 타입과 개수가 일치하는 부모 생성자를 호출
 */

public 자식클래스(...) {
    super(매개값, ...);
    ...
}
```

- 부모클래스 생성자에 매개변수가 없는 경우 컴파일시 자동으로 생성
- 부모클래스 생성자에 매개변수가 있는 경우 반드시 `super(매개변수)` 작성



### 7.4 메소드 재정의

> 부모의 메소드가 자식 클래스에서 사용하기 적합하지 않을 때 자식클래스에서 재정의해서 사용해야 한다.
>
> 이것을 **메소드 오버라이딩** 이라고한다.

##### 메소드 오버라이딩

- 상속된 메소드를 자식 클래스에서 재정의 하는 것
- 메소드 오버라이딩이 되면 해당 부모 메소드는 숨겨지고, 자식 메소드가 우선적으로 사용된다.
- 다음 규직을 주의해서 작성해야 한다.
  - 부모 메소드의 선언부(리턴 타입, 메소드 이름, 매개변수)와 동일해야 한다.
  - 접근 제한을 더 강하게 오버라이딩할 수 없다.(public -> private으로 변경 불가)
  - 새로운 예외를 throws할 수 없다.

- `@Override`를 붙이면 컴파일 단계에서 정확히 오버라이딩이 되었는지 체크하고, 문제가 있다면 컴파일 에러 출력

##### 부모의 메소드 호출

> 메소드를 재정의하면, 부모 메소드는 숨겨지고 자식 메소드만 사용되기 때문에 
>
> 부모의 메소드의 일부만 변경된다 하더라도 중복된 내용을 자식 메소드도 가지고 있어야 한다.
>
> 이 문제는 자식 메소드와 부모 메소드의 공동 작업 처리 기법을 이용해서 해결

- 자식 메소드 내에서 부모의 메소드를 호출 `super.`으로 호출
- 부모 메소드를 재사용함으로써 자식 메소드의 중복 작업 내용을 없앤다.



### 7.5  final 클래스와 final 메소드

##### final 클래스

- final 클래스는 무보 클래스가 될 수 없다.(자식 클래스를 만들 수 없다.)

##### final 메소드

- 부모 클래스를 상속해서 자식 클래스를 선언할 때, 부모 클래스에 선언된 final 메소드는 자식 클래스에서 재정의할 수 없다.